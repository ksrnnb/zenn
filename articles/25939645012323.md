---
title: "sync.Mutex ã®ä»•çµ„ã¿ã‚’èª¿ã¹ã¦ã¿ãŸ"
emoji: "ğŸ”’"
type: "tech"
topics:
  - "go"
  - "ä¸¦è¡Œå‡¦ç†"
published: true
published_at: "2023-02-01 10:00"
---

# ã¯ã˜ã‚ã«
sync.Mutex ã® `Lock` ãƒ¡ã‚½ãƒƒãƒ‰ã‚„ `Unlcok` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã†ã“ã¨ã§ã‚¢ãƒˆãƒŸãƒƒã‚¯ã«å€¤ã®æ“ä½œã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™ãŒã€ã“ã‚Œã‚‰ã®ä»•çµ„ã¿ãŒä¸€ä½“ã©ã†ãªã£ã¦ã„ã‚‹ã®ã‹èª¿ã¹ã¦ã¿ãŸã®ã§è¨˜äº‹ã«ã¾ã¨ã‚ã¾ã—ãŸã€‚

# ã–ã£ãã‚Šã¾ã¨ã‚
2ã¤ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã§ `sync.Mutex` ã‚’åˆ©ç”¨ã—ã¦ lock/unlock ã™ã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å›³ã‚’ä»¥ä¸‹ã«ã¾ã¨ã‚ã¾ã—ãŸã€‚ `sync.Mutex` ã«ã¯ `state` ã¨ `sema` ã®2ã¤ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒã‚ã‚Šã€ã“ã‚Œã‚‰ã®å€¤ã«ã‚ˆã£ã¦çŠ¶æ…‹ã‚’ä¿æŒã—ã¾ã™ã€‚

`Lock` ãƒ¡ã‚½ãƒƒãƒ‰å®Ÿè¡Œæ™‚ã«æ—¢ã« lock ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ `runtime_SemacquireMutex` é–¢æ•°ã§å¾…æ©Ÿã—ã¾ã™ã€‚ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã§ `Unlock` ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®Ÿè¡Œã•ã‚Œã¦ã€ãã®ä¸­ã§ `runtime_Semrelease` é–¢æ•°ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã¨ã€ `runtime_SemacquireMutex` é–¢æ•°ã§å¾…æ©Ÿã—ã¦ã„ãŸã‚¹ãƒ¬ãƒƒãƒ‰ã« notify ã•ã‚Œã¦å‡¦ç†ãŒå†é–‹ã—ã¾ã™ã€‚

æ¬¡ã®ç« ã‹ã‚‰ã€`sync.Mutex` ã®ä½¿ã„æ–¹ã‚„ã€è©³ç´°ã‚’ã¿ã¦ã„ãã¾ã™ã€‚

![Mutexã‚’ç”¨ã„ãŸLock/Unlockã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å›³](https://storage.googleapis.com/zenn-user-upload/43b0143ad5f5-20230201.png)

# ä½¿ã„æ–¹
ã‹ã‚“ãŸã‚“ã« `sync.Mutex` ã®ä½¿ã„æ–¹ã‚’ãŠã•ã‚‰ã„ã—ã¾ã™ã€‚
ä»Šå›ã¯ã€[A Tour of Go](https://go.dev/tour/concurrency/9) ã®ã‚³ãƒ¼ãƒ‰ã‚’ä¾‹ã«ã¿ã¦ã¿ã¾ã™ã€‚

ä»¥ä¸‹ã®ã‚ˆã†ã«ã€ `sync.Mutex` å‹ã®å¤‰æ•°ã‚’ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã‚‚ã¤ `SafeCounter` æ§‹é€ ä½“ã‚’å®šç¾©ã—ãŸã¨ã—ã¾ã™ã€‚ 
`Inc` ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚¢ãƒˆãƒŸãƒƒã‚¯ã«å€¤ã‚’æ“ä½œã—ã¦ã„ã¾ã™ãŒã€ã“ã®ã‚ˆã†ã«[ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã‚»ã‚¯ã‚·ãƒ§ãƒ³](https://en.wikipedia.org/wiki/Critical_section)ã‚’ `Lock` ãƒ¡ã‚½ãƒƒãƒ‰ã¨ `Unlock` ãƒ¡ã‚½ãƒƒãƒ‰ã§å›²ã‚€ã‚ˆã†ã«ä½¿ç”¨ã—ã¾ã™ã€‚ `defer c.mu.Unlock()` ã®ã‚ˆã†ã«æ›¸ãã“ã¨ã‚‚å¤šã„ã‹ã¨æ€ã„ã¾ã™ã€‚

```go
// SafeCounter is safe to use concurrently.
type SafeCounter struct {
	mu sync.Mutex
	v  map[string]int
}

// Inc increments the counter for the given key.
func (c *SafeCounter) Inc(key string) {
	c.mu.Lock()
	// Lock so only one goroutine at a time can access the map c.v.
	c.v[key]++
	c.mu.Unlock()
}
```

# Mutex æ§‹é€ ä½“
å…ˆã»ã©ã€`sync.Mutex` ã‚’ã‚¼ãƒ­å€¤ã®ã¾ã¾ä½¿ã†ä¾‹ã‚’ç¤ºã—ã¾ã—ãŸãŒã€æ§‹é€ ä½“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚ `sync.Mutex` ã®ã‚¼ãƒ­å€¤ã¯ unlock ã•ã‚Œã¦ã„ã‚‹çŠ¶æ…‹ã¨ãªã‚‹ã®ã§ã€`state` ã¨ `sema` ãŒ0ã®å ´åˆã¯ unlock ã•ã‚Œã¦ã„ã¾ã™ã€‚

```go
type Mutex struct {
	state int32
	sema  uint32
}
```

# Lock ã®ä»•çµ„ã¿
sync ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ã¿ã¦ã¿ã‚‹ã¨ã€`Lock` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚

```go
// Lock locks m.
// If the lock is already in use, the calling goroutine
// blocks until the mutex is available.
func (m *Mutex) Lock() {
	// Fast path: grab unlocked mutex.
	if atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked) {
		if race.Enabled {
			race.Acquire(unsafe.Pointer(m))
		}
		return
	}
	// Slow path (outlined so that the fast path can be inlined)
	m.lockSlow()
}
```

`CompareAndSwapInt32` ã¯åˆè¦‹ã ã¨ä½•ã‚„ã£ã¦ã‚‹ã‹ã‚ˆãã‚ã‹ã‚‰ãªã„ã‹ã¨æ€ã„ã¾ã™ã€‚ã“ã‚Œã¯ã€[Compare-and-swap(CAS)](https://en.wikipedia.org/wiki/Compare-and-swap) ã¨å‘¼ã°ã‚Œã‚‹ã‚¢ãƒˆãƒŸãƒƒã‚¯ãªå‘½ä»¤ã«ãªã‚Šã¾ã™ã€‚æŒ‡å®šã—ãŸãƒã‚¤ãƒ³ã‚¿ã®å€¤ã‚’æ¯”è¼ƒ (compare) ã—ã¦ã€ç­‰ã—ã„å ´åˆã«ã¯å€¤ã‚’äº¤æ› (swap) ã—ã¾ã™ã€‚

CAS ã®æ“¬ä¼¼çš„ãªã‚³ãƒ¼ãƒ‰ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ pointer ãŒæŒ‡ã—ã¦ã„ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã®å€¤ãŒ old ã¨ç­‰ã—ã„å ´åˆã¯ã€ new ã®å€¤ã‚’ä»£å…¥ã—ã¦ true ã‚’è¿”ã—ã€ç­‰ã—ããªã„å ´åˆã¯ä½•ã‚‚ã—ãªã„ã¾ã¾ false ã‚’è¿”ã—ã¾ã™ã€‚

```go
function cas(p: pointer to int, old: int, new: int) is
    if *p â‰  old
        return false

    *p â† new

    return true
```

ã¤ã¾ã‚Šã€`atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked)` ã§ã¯ã€ `state` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å€¤ãŒ0ã®å ´åˆã¯ `state` ã‚’ `mutexLocked` ã«æ›´æ–°ã—ã¦ã€true ã‚’è¿”ã—ã¾ã™ã€‚ 

ã¡ãªã¿ã«ã€state ã®å€¤ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã•ã‚ŒãŸå®šæ•°ãŒåˆ©ç”¨ã•ã‚Œã¾ã™ã€‚
```go
const (
	mutexLocked = 1 << iota // mutex is locked
	mutexWoken
	mutexStarving
	mutexWaiterShift = iota
)
```

ãã®å¾Œã® `race.Enabled` ã¯å®šæ•°ã® false ãªã®ã§ç„¡è¦–ã—ã¦è‰¯ã•ãã†ã§ã™ã€‚ã—ãŸãŒã£ã¦ã€1å›ç›®ã® `Lock` ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯ `state` ã« `mutexLocked` ãƒ•ãƒ©ã‚°ã‚’ä»£å…¥ã—ã¦ã€å‡¦ç†ãŒçµ‚ã‚ã‚Šã¾ã™ã€‚

ã¤ã¥ã‘ã¦ unlock ã—ãªã„ã¾ã¾ã€ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãªã©ã§ lock ã—ãŸå ´åˆã‚’è€ƒãˆã¦ã¿ã¾ã™ã€‚
ã™ã‚‹ã¨ã€ `atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked)` ã¯ `state` ã®å€¤ãŒ0ã§ã¯ãªã„ã®ã§ã€false ã‚’è¿”ã—ã¾ã™ã€‚ã—ãŸãŒã£ã¦ã€2å›ç›®ã®å®Ÿè¡Œã§ã¯ `lockSlow` ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚

## lockSlow
`lockSlow` ã¯è¤‡é›‘ãªå‡¦ç†ã‚’ã—ã¦ã„ã‚‹ã®ã§ã™ãŒã€ ã‹ãªã‚Šã–ã£ãã‚Šã¨æ›¸ãã¨ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚ `m.state` ã‚’æ–°ã—ã„å€¤ã«æ›´æ–°ã—ãŸå¾Œã€`runtime_SemacquireMutex` ã‚’å®Ÿè¡Œã—ã¦ã„ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€ç¬¬ä¸€å¼•æ•°ã®ãƒã‚¤ãƒ³ã‚¿ãŒæŒ‡ã™å€¤ãŒ0ã‚ˆã‚Šã‚‚å¤§ãããªã‚‹ã¾ã§å¾…æ©Ÿã—ã¾ã™ã€‚ `runtime_SemacquireMutex` ã®è©³ç´°ãŒæ°—ã«ãªã‚‹æ–¹ã¯ã€runtime ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã® [sema.go](https://cs.opensource.google/go/go/+/refs/tags/go1.19.5:src/runtime/sema.go;l=76) ã‚’èª­ã‚“ã§ã¿ã¦ãã ã•ã„ã€‚

`Lock` ãƒ¡ã‚½ãƒƒãƒ‰ãŒ2å›å‘¼ã°ã‚Œã¦ã€ã¾ã  unlock ã•ã‚Œã¦ã„ãªã„ã¨ä»®å®šã™ã‚‹ã¨ `m.sema` ã®å€¤ã¯0ã«ãªã‚‹ã®ã§ã€ã“ã“ã§å€¤ãŒå¤‰ã‚ã‚‹ã®ã‚’å¾…æ©Ÿã—ã¾ã™ã€‚

```go
func (m *Mutex) lockSlow() {
	for {
		...
		if atomic.CompareAndSwapInt32(&m.state, old, new) {
			...
			runtime_SemacquireMutex(&m.sema, queueLifo, 1)
			...
		}
		...
	}
}
```


# Unlock ã®ä»•çµ„ã¿
`Unlock` ã®ã‚³ãƒ¼ãƒ‰ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ `AddInt32` ã®è¿”ã‚Šå€¤ã¯è¨ˆç®—ã—ãŸçµæœã¨ãªã‚‹ã®ã§ã€`m.state` ã®å€¤ãŒ `mutexLocked` ã ã£ãŸå ´åˆã¯ `m.state` ã®å€¤ãŒ0ã«ãªã£ã¦å‡¦ç†ãŒçµ‚äº†ã—ã¾ã™ã€‚
ãã‚Œä»¥å¤–ã®å ´åˆã¯ã€ `unlockSlow` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚ã¤ã¾ã‚Šã€å…ˆã»ã©ã® `lockSlow` ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚ˆã£ã¦ `m.state` ãŒ `mutexLocked` ä»¥å¤–ã®å€¤ã«æ›´æ–°ã•ã‚Œã¦ã„ãŸå ´åˆã¯ã€ã“ã® `unlockSlow` ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚

```go
func (m *Mutex) Unlock() {
	if race.Enabled {
		_ = m.state
		race.Release(unsafe.Pointer(m))
	}

	// Fast path: drop lock bit.
	new := atomic.AddInt32(&m.state, -mutexLocked)
	if new != 0 {
		// Outlined slow path to allow inlining the fast path.
		// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.
		m.unlockSlow(new)
	}
}
```

## unlockSlow
`unlockSlow` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‹ãªã‚Šã–ã£ãã‚Šã¨æ›¸ãã¨ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚
`runtime_Semrelease` ã§ `&m.sema` ã®å€¤ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã¦ã€ Semacquire ã§å¾…æ©Ÿã—ã¦ã„ã‚‹ã‚´ãƒ«ãƒ¼ãƒãƒ³ã« notify ã—ã¾ã™ã€‚
ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚è©³ç´°ãŒæ°—ã«ãªã‚‹æ–¹ã¯ã€[sema.go](https://cs.opensource.google/go/go/+/refs/tags/go1.19.5:src/runtime/sema.go;l=71)ã‚’èª­ã‚“ã§ã¿ã¦ãã ã•ã„ã€‚

ã—ãŸãŒã£ã¦ã€`unlockSlow` ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã§ã€`lockSlow` ã® `runtime_SemacquireMutex` ã§å¾…æ©Ÿã—ã¦ã„ãŸã‚¹ãƒ¬ãƒƒãƒ‰ã«é€šçŸ¥ãŒã¨ã‚“ã§ã€å‡¦ç†ãŒå†é–‹ã™ã‚‹ã¨ã„ã†æµã‚Œã«ãªã‚Šã¾ã™ã€‚

```go
func (m *Mutex) unlockSlow(new int32) {
	...
	runtime_Semrelease(&m.sema, false, 1)
	...
}
```

# ã•ã„ã”ã«
ã“ã“ã¾ã§ã§ `Lock` ã¨ `Unlock` ã®è©³ç´°ã‚’ã¿ã¦ããŸã®ã§ã€å›³ã‚’å†æ²ã—ã¦ãŠãã¾ã™ã€‚ã“ã®è¨˜äº‹ã‚’èª­ã‚€ã‚ˆã‚Šã€å°‘ã—ã§ã‚‚ `sync.Mutex` ã®å‡¦ç†ãŒã‚¤ãƒ¡ãƒ¼ã‚¸ã—ã‚„ã™ããªã‚Œã°å¹¸ã„ã§ã™ã€‚

![Mutexã‚’ç”¨ã„ãŸLock/Unlockã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å›³](https://storage.googleapis.com/zenn-user-upload/43b0143ad5f5-20230201.png)